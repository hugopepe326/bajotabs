<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bass Tab Extractor</title>

<!-- jsPDF for PDF generation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Mono:ital,wght@0,300;0,400;0,500;1,300&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0a0a0a;
    --surface: #111111;
    --border: #222;
    --accent: #e8c05a;
    --accent2: #c4753a;
    --fg: #f0ead6;
    --muted: #666;
    --danger: #e05555;
  }

  body {
    background: var(--bg);
    color: var(--fg);
    font-family: 'DM Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 0 20px 60px;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 0;
    opacity: 0.35;
  }

  header {
    width: 100%;
    max-width: 680px;
    padding: 56px 0 32px;
    position: relative;
    z-index: 1;
  }

  .logo {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(48px, 8vw, 80px);
    letter-spacing: 0.06em;
    line-height: 0.9;
    color: var(--accent);
    text-shadow: 4px 4px 0 var(--accent2);
  }

  .logo span { color: var(--fg); }

  .subtitle {
    margin-top: 10px;
    font-size: 11px;
    letter-spacing: 0.2em;
    color: var(--muted);
    text-transform: uppercase;
  }

  .strings-deco {
    width: 100%;
    max-width: 680px;
    height: 28px;
    position: relative;
    margin: 8px 0 32px;
    z-index: 1;
  }
  .strings-deco::before,
  .strings-deco::after,
  .strings-deco .s3,
  .strings-deco .s4 {
    content: '';
    position: absolute;
    left: 0; right: 0;
    height: 1px;
    opacity: 0.25;
  }
  .strings-deco::before { top: 4px; background: var(--fg); }
  .strings-deco .s3 { top: 11px; background: var(--fg); opacity: 0.18; }
  .strings-deco .s4 { top: 18px; background: var(--fg); opacity: 0.12; }
  .strings-deco::after { top: 25px; background: var(--fg); opacity: 0.08; }

  .tab-preview {
    width: 100%;
    max-width: 680px;
    margin-bottom: 28px;
    position: relative;
    z-index: 1;
  }
  .tab-preview-label {
    font-size: 9px;
    letter-spacing: 0.18em;
    color: var(--muted);
    text-transform: uppercase;
    margin-bottom: 14px;
  }
  .tab-strings { display: flex; flex-direction: column; gap: 10px; }
  .tab-string-row { display: flex; align-items: center; gap: 8px; }
  .tab-string-name { width: 14px; font-size: 10px; color: var(--accent); font-weight: 500; flex-shrink: 0; }
  .tab-string-line { flex: 1; height: 1px; background: var(--border); position: relative; }
  .tab-dot {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 18px; height: 18px;
    background: var(--accent);
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 8px; font-weight: 700;
    color: #0a0a0a;
    margin-top: -1px;
    font-family: 'DM Mono', monospace;
  }

  .card {
    width: 100%;
    max-width: 680px;
    background: var(--surface);
    border: 1px solid var(--border);
    padding: 40px;
    position: relative;
    z-index: 1;
  }

  .dropzone {
    border: 1.5px dashed var(--border);
    padding: 48px 24px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    position: relative;
    overflow: hidden;
  }
  .dropzone:hover, .dropzone.dragover {
    border-color: var(--accent);
    background: rgba(232,192,90,0.04);
  }
  .dropzone input[type="file"] {
    position: absolute; inset: 0; opacity: 0; cursor: pointer; font-size: 0;
  }
  .drop-icon { font-size: 40px; line-height: 1; margin-bottom: 14px; display: block; }
  .drop-label { font-size: 13px; color: var(--muted); letter-spacing: 0.08em; }
  .drop-label strong { color: var(--accent); font-weight: 500; }
  .file-name { margin-top: 12px; font-size: 11px; color: var(--accent); letter-spacing: 0.05em; min-height: 16px; }

  /* Song/Artist inputs */
  .meta-inputs {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-top: 24px;
  }
  .meta-field { display: flex; flex-direction: column; gap: 6px; }
  .meta-label { font-size: 9px; letter-spacing: 0.18em; color: var(--muted); text-transform: uppercase; }
  .meta-input {
    background: transparent;
    border: none;
    border-bottom: 1px solid var(--border);
    color: var(--fg);
    font-family: 'DM Mono', monospace;
    font-size: 12px;
    padding: 6px 0;
    outline: none;
    transition: border-color 0.2s;
    letter-spacing: 0.05em;
  }
  .meta-input:focus { border-bottom-color: var(--accent); }
  .meta-input::placeholder { color: var(--border); }

  .btn {
    display: block; width: 100%; margin-top: 24px; padding: 16px;
    background: var(--accent); color: #0a0a0a;
    border: none; font-family: 'Bebas Neue', sans-serif;
    font-size: 20px; letter-spacing: 0.15em;
    cursor: pointer; transition: background 0.15s, transform 0.1s;
  }
  .btn:hover:not(:disabled) { background: #f0d070; transform: translateY(-1px); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

  .progress-wrap { margin-top: 28px; display: none; }
  .progress-wrap.visible { display: block; }
  .progress-label { font-size: 10px; letter-spacing: 0.2em; color: var(--muted); text-transform: uppercase; margin-bottom: 8px; }
  .progress-bar-outer { width: 100%; height: 3px; background: var(--border); overflow: hidden; }
  .progress-bar-inner {
    height: 100%; background: var(--accent); width: 0%;
    transition: width 0.4s ease;
  }
  .progress-steps { margin-top: 16px; display: flex; flex-direction: column; gap: 6px; }
  .step {
    font-size: 10px; letter-spacing: 0.12em; color: var(--border);
    transition: color 0.3s; display: flex; gap: 8px; align-items: center;
  }
  .step.done { color: var(--accent); }
  .step.active { color: var(--fg); }
  .step-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; flex-shrink: 0; }

  .result { margin-top: 28px; padding: 20px; border: 1px solid var(--accent); background: rgba(232,192,90,0.06); display: none; }
  .result.visible { display: block; }
  .result-title { font-size: 10px; letter-spacing: 0.2em; color: var(--accent); text-transform: uppercase; margin-bottom: 12px; }
  .result-info { font-size: 11px; color: var(--muted); margin-bottom: 16px; line-height: 1.8; }
  .btn-download {
    display: inline-flex; align-items: center; gap: 8px; padding: 10px 20px;
    background: transparent; border: 1px solid var(--accent);
    color: var(--accent); font-family: 'DM Mono', monospace;
    font-size: 11px; letter-spacing: 0.15em; text-transform: uppercase;
    cursor: pointer; text-decoration: none; transition: background 0.15s, color 0.15s;
  }
  .btn-download:hover { background: var(--accent); color: #0a0a0a; }

  .error-box {
    margin-top: 20px; padding: 14px 18px;
    border: 1px solid var(--danger); background: rgba(224,85,85,0.07);
    font-size: 11px; color: var(--danger); display: none;
    letter-spacing: 0.05em; line-height: 1.7;
  }
  .error-box.visible { display: block; }

  .info-grid {
    width: 100%; max-width: 680px;
    display: grid; grid-template-columns: repeat(4, 1fr);
    gap: 1px; margin-top: 1px;
    background: var(--border);
    position: relative; z-index: 1;
  }
  .info-cell {
    background: var(--surface);
    padding: 18px 16px;
  }
  .info-cell-label { font-size: 9px; letter-spacing: 0.18em; color: var(--muted); text-transform: uppercase; margin-bottom: 8px; }
  .info-cell-value { font-size: 11px; color: var(--fg); line-height: 1.6; }

  @media (max-width: 500px) {
    .info-grid { grid-template-columns: repeat(2, 1fr); }
    .meta-inputs { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<header>
  <div class="logo">BASS<span>TAB</span><br>EXTRACTOR</div>
  <p class="subtitle">MP3 â†’ Electric Bass Tablature â†’ PDF Â· 100% Client-side</p>
</header>

<div class="strings-deco">
  <div class="s3"></div>
  <div class="s4"></div>
</div>

<div class="tab-preview">
  <div class="tab-preview-label">Output preview â€” 4 strings Â· Standard tuning Â· A4 PDF</div>
  <div class="tab-strings" id="tabPreview">
    <div class="tab-string-row"><span class="tab-string-name">G</span><div class="tab-string-line"></div></div>
    <div class="tab-string-row"><span class="tab-string-name">D</span><div class="tab-string-line"></div></div>
    <div class="tab-string-row"><span class="tab-string-name">A</span><div class="tab-string-line"></div></div>
    <div class="tab-string-row"><span class="tab-string-name">E</span><div class="tab-string-line"></div></div>
  </div>
</div>

<div class="card">
  <div class="dropzone" id="dropzone">
    <input type="file" id="fileInput" accept=".mp3,audio/mpeg" />
    <span class="drop-icon">ðŸŽµ</span>
    <div class="drop-label">
      <strong>Click or drag</strong> an MP3 file here<br>
      Max 50 MB Â· Bass or single instrument tracks work best
    </div>
    <div class="file-name" id="fileName"></div>
  </div>

  <div class="meta-inputs">
    <div class="meta-field">
      <label class="meta-label" for="songName">Song</label>
      <input class="meta-input" type="text" id="songName" placeholder="Song title..." />
    </div>
    <div class="meta-field">
      <label class="meta-label" for="artistName">Artist</label>
      <input class="meta-input" type="text" id="artistName" placeholder="Artist name..." />
    </div>
  </div>

  <button class="btn" id="processBtn" disabled onclick="processFile()">
    EXTRACT BASS TAB
  </button>

  <div class="progress-wrap" id="progressWrap">
    <div class="progress-label">Processing</div>
    <div class="progress-bar-outer">
      <div class="progress-bar-inner" id="progressBar"></div>
    </div>
    <div class="progress-steps">
      <div class="step" id="step1"><div class="step-dot"></div>Decoding audio</div>
      <div class="step" id="step2"><div class="step-dot"></div>Detecting pitch (YIN algorithm)</div>
      <div class="step" id="step3"><div class="step-dot"></div>Mapping notes to bass fretboard</div>
      <div class="step" id="step4"><div class="step-dot"></div>Generating PDF tablature</div>
    </div>
  </div>

  <div class="error-box" id="errorBox"></div>

  <div class="result" id="resultBox">
    <div class="result-title">âœ“ Tablature ready</div>
    <div class="result-info" id="resultInfo"></div>
    <a class="btn-download" id="downloadLink" href="#" download>â†“ DOWNLOAD PDF</a>
  </div>
</div>

<div class="info-grid">
  <div class="info-cell">
    <div class="info-cell-label">Tuning</div>
    <div class="info-cell-value">E Â· A Â· D Â· G<br><span style="color:var(--muted);font-size:10px">Standard 4-string</span></div>
  </div>
  <div class="info-cell">
    <div class="info-cell-label">Algorithm</div>
    <div class="info-cell-value">YIN<br><span style="color:var(--muted);font-size:10px">Time-domain pitch detection</span></div>
  </div>
  <div class="info-cell">
    <div class="info-cell-label">Output</div>
    <div class="info-cell-value">PDF A4<br><span style="color:var(--muted);font-size:10px">Printable tablature</span></div>
  </div>
  <div class="info-cell">
    <div class="info-cell-label">Best results</div>
    <div class="info-cell-value">Isolated bass<br><span style="color:var(--muted);font-size:10px">Stems or DI recordings</span></div>
  </div>
</div>

<script>
// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STRINGS = [
  { name: "G", midi: 43 },
  { name: "D", midi: 38 },
  { name: "A", midi: 33 },
  { name: "E", midi: 28 },
];
const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

// Bass frequency range: E1 (41.2 Hz) to G3 (196 Hz)
const F_MIN = 41.2;
const F_MAX = 196.0;

// â”€â”€â”€ Music Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function freqToMidi(freq) {
  return 69 + 12 * Math.log2(freq / 440);
}
function midiToNoteName(midi) {
  const oct = Math.floor(midi / 12) - 1;
  return NOTE_NAMES[midi % 12] + oct;
}
function midiToTab(midi) {
  let best = null, bestFret = 999;
  for (const s of STRINGS) {
    const fret = Math.round(midi) - s.midi;
    if (fret >= 0 && fret <= 24 && fret < bestFret) {
      bestFret = fret;
      best = { string: s.name, fret };
    }
  }
  return best;
}

// â”€â”€â”€ YIN Pitch Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Implements de CheveignÃ© & Kawahara (2002) YIN algorithm
function yinPitch(buffer, sampleRate, threshold = 0.15) {
  const W = buffer.length;
  const half = Math.floor(W / 2);
  const d = new Float32Array(half);

  // Step 1: Difference function
  for (let tau = 1; tau < half; tau++) {
    let sum = 0;
    for (let j = 0; j < half; j++) {
      const diff = buffer[j] - buffer[j + tau];
      sum += diff * diff;
    }
    d[tau] = sum;
  }

  // Step 2: Cumulative mean normalized difference
  const cmnd = new Float32Array(half);
  cmnd[0] = 1;
  let runningSum = 0;
  for (let tau = 1; tau < half; tau++) {
    runningSum += d[tau];
    cmnd[tau] = d[tau] * tau / runningSum;
  }

  // Step 3: Absolute threshold
  const minPeriod_samples = Math.floor(sampleRate / F_MAX);
  const maxPeriod_samples = Math.floor(sampleRate / F_MIN);

  let tau = minPeriod_samples;
  while (tau < Math.min(maxPeriod_samples, half - 1)) {
    if (cmnd[tau] < threshold) {
      // Find local minimum
      while (tau + 1 < half && cmnd[tau + 1] < cmnd[tau]) tau++;
      break;
    }
    tau++;
  }

  if (tau >= Math.min(maxPeriod_samples, half - 1)) return null;
  if (cmnd[tau] >= threshold) return null;

  // Step 4: Parabolic interpolation for better precision
  let betterTau = tau;
  if (tau > 0 && tau < half - 1) {
    const s0 = cmnd[tau - 1];
    const s1 = cmnd[tau];
    const s2 = cmnd[tau + 1];
    betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
  }

  return sampleRate / betterTau;
}

// â”€â”€â”€ Audio Processing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function extractNotes(arrayBuffer, onProgress) {
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

  // Mix down to mono
  const numChannels = audioBuffer.numberOfChannels;
  const length = audioBuffer.length;
  const sampleRate = audioBuffer.sampleRate;
  const mono = new Float32Array(length);
  for (let c = 0; c < numChannels; c++) {
    const ch = audioBuffer.getChannelData(c);
    for (let i = 0; i < length; i++) mono[i] += ch[i] / numChannels;
  }

  // Apply a simple low-pass filter bias toward bass frequencies
  // (basic 2-pole Butterworth at ~300Hz to reduce overtones)
  const lpMono = lowPass(mono, sampleRate, 300);

  // YIN frame analysis
  const HOP = Math.floor(sampleRate * 0.04);    // 40ms hop
  const WIN = Math.floor(sampleRate * 0.08);    // 80ms window (needs 2x for YIN half)
  const totalFrames = Math.floor((length - WIN) / HOP);

  const rawNotes = [];
  const frameTime = HOP / sampleRate;
  let prevMidi = null;
  let noteStart = 0;
  let noteDur = 0;

  for (let fi = 0; fi < totalFrames; fi++) {
    if (fi % 100 === 0) onProgress(10 + (fi / totalFrames) * 65);

    const start = fi * HOP;
    const frame = lpMono.slice(start, start + WIN);

    // RMS gate: skip silent frames
    let rms = 0;
    for (let s of frame) rms += s * s;
    rms = Math.sqrt(rms / frame.length);
    if (rms < 0.003) {
      if (prevMidi !== null) {
        if (noteDur >= 0.06) rawNotes.push({ time: noteStart, duration: noteDur, midi: prevMidi });
        prevMidi = null;
      }
      continue;
    }

    const freq = yinPitch(frame, sampleRate, 0.12);
    if (!freq) {
      if (prevMidi !== null) {
        if (noteDur >= 0.06) rawNotes.push({ time: noteStart, duration: noteDur, midi: prevMidi });
        prevMidi = null;
      }
      continue;
    }

    const midiRaw = freqToMidi(freq);
    const midi = Math.round(midiRaw);
    const t = fi * frameTime;

    if (midi === prevMidi) {
      noteDur += frameTime;
    } else {
      if (prevMidi !== null && noteDur >= 0.06) {
        rawNotes.push({ time: noteStart, duration: noteDur, midi: prevMidi });
      }
      prevMidi = midi;
      noteStart = t;
      noteDur = frameTime;
    }
  }
  if (prevMidi !== null && noteDur >= 0.06) {
    rawNotes.push({ time: noteStart, duration: noteDur, midi: prevMidi });
  }

  // Map to tab positions
  const notes = rawNotes
    .map(n => {
      const tab = midiToTab(n.midi);
      if (!tab) return null;
      return { ...n, noteName: midiToNoteName(n.midi), string: tab.string, fret: tab.fret };
    })
    .filter(Boolean);

  audioCtx.close();
  return notes;
}

// â”€â”€â”€ Simple IIR Low-Pass Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function lowPass(input, sampleRate, cutoff) {
  const RC = 1 / (2 * Math.PI * cutoff);
  const dt = 1 / sampleRate;
  const alpha = dt / (RC + dt);
  const out = new Float32Array(input.length);
  out[0] = input[0];
  for (let i = 1; i < input.length; i++) {
    out[i] = out[i - 1] + alpha * (input[i] - out[i - 1]);
  }
  return out;
}

// â”€â”€â”€ PDF Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generatePDF(notes, songName, artistName) {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });

  const PW = 595.28;
  const PH = 841.89;

  // Design constants matching the reference image
  const MARGIN_L = 36;
  const MARGIN_R = 36;
  const CONTENT_W = PW - MARGIN_L - MARGIN_R;

  // Header
  const HEADER_Y = 40;
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(10);
  doc.setTextColor(0);

  // Song label + line
  doc.text('Song', MARGIN_L, HEADER_Y);
  const songLabelW = doc.getTextWidth('Song');
  const songLineStart = MARGIN_L + songLabelW + 4;
  const songLineEnd = MARGIN_L + 220;

  // Fill song name or underline
  doc.setFontSize(9);
  if (songName) {
    doc.setFont('helvetica', 'italic');
    doc.text(songName, songLineStart + 2, HEADER_Y - 1);
    doc.setFont('helvetica', 'normal');
  }
  doc.setLineWidth(0.5);
  doc.line(songLineStart, HEADER_Y + 2, songLineEnd, HEADER_Y + 2);

  // Artist label + line
  const artistX = MARGIN_L + 240;
  doc.setFontSize(10);
  doc.text('Artist', artistX, HEADER_Y);
  const artistLabelW = doc.getTextWidth('Artist');
  const artistLineStart = artistX + artistLabelW + 4;
  const artistLineEnd = PW - MARGIN_R;

  doc.setFontSize(9);
  if (artistName) {
    doc.setFont('helvetica', 'italic');
    doc.text(artistName, artistLineStart + 2, HEADER_Y - 1);
    doc.setFont('helvetica', 'normal');
  }
  doc.line(artistLineStart, HEADER_Y + 2, artistLineEnd, HEADER_Y + 2);

  // â”€â”€ Tab Staff Layout
  const TAB_LABEL_W = 14;       // space for T A B text
  const STAFF_START_X = MARGIN_L + TAB_LABEL_W + 4;
  const STAFF_W = CONTENT_W - TAB_LABEL_W - 4;
  const STRING_SPACING = 11;    // px between strings
  const STAFF_H = STRING_SPACING * 3; // G D A E â†’ 3 gaps
  const MEASURES_PER_ROW = 4;
  const MEASURE_W = STAFF_W / MEASURES_PER_ROW;

  // Timing: assume 4/4 at 100 BPM = 2.4s/measure, auto-detect from note density
  let bpm = 100;
  if (notes.length > 4) {
    // Estimate BPM from average note density
    const span = notes[notes.length - 1].time - notes[0].time;
    const density = notes.length / span; // notes/sec
    bpm = Math.max(60, Math.min(160, Math.round(density * 30)));
  }
  const MEASURE_DUR = (60 / bpm) * 4; // seconds per measure (4/4)
  const ROW_DUR = MEASURE_DUR * MEASURES_PER_ROW;

  // Row positions
  const FIRST_ROW_Y = HEADER_Y + 28;
  const ROW_STEP = STAFF_H + 36; // space between staves
  const ROWS_PER_PAGE = Math.floor((PH - FIRST_ROW_Y - 20) / ROW_STEP);

  const maxTime = notes.length > 0 ? notes[notes.length - 1].time + 1 : 1;
  const totalRows = Math.ceil(maxTime / ROW_DUR);

  const STRING_MAP = { G: 0, D: 1, A: 2, E: 3 };

  function drawStaff(rowIdx, yTop) {
    const measureNum = rowIdx * MEASURES_PER_ROW + 1;

    // Measure number (small, above-left of staff)
    if (rowIdx > 0) {
      doc.setFontSize(6.5);
      doc.setFont('helvetica', 'italic');
      doc.setTextColor(80);
      doc.text(String(measureNum), MARGIN_L, yTop - 2);
    }

    doc.setTextColor(0);
    doc.setLineWidth(0.4);

    // 4 horizontal string lines
    for (let si = 0; si < 4; si++) {
      const ly = yTop + si * STRING_SPACING;
      doc.line(STAFF_START_X, ly, STAFF_START_X + STAFF_W, ly);
    }

    // Vertical bar lines (5 lines: start + 3 internal + end)
    doc.setLineWidth(0.6);
    for (let bi = 0; bi <= MEASURES_PER_ROW; bi++) {
      const bx = STAFF_START_X + bi * MEASURE_W;
      doc.line(bx, yTop, bx, yTop + STAFF_H);
    }

    // TAB vertical label (T A B) at left, vertically centered
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(6);
    doc.setTextColor(0);
    const tabX = MARGIN_L + TAB_LABEL_W - 2;
    doc.text('T', tabX, yTop + 1, { align: 'center' });
    doc.text('A', tabX, yTop + STRING_SPACING + 1, { align: 'center' });
    doc.text('B', tabX, yTop + STRING_SPACING * 2 + 1, { align: 'center' });
  }

  function drawNote(note, rowStartTime, yTop) {
    const relTime = note.time - rowStartTime;
    if (relTime < 0 || relTime >= ROW_DUR) return;

    const nx = STAFF_START_X + (relTime / ROW_DUR) * STAFF_W;
    const si = STRING_MAP[note.string] ?? 3;
    const ny = yTop + si * STRING_SPACING;

    const fretStr = String(note.fret);
    const fw = fretStr.length > 1 ? 9 : 7;

    // White rectangle mask behind number
    doc.setFillColor(255, 255, 255);
    doc.rect(nx - fw / 2, ny - 5, fw, 7, 'F');

    // Fret number
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(7);
    doc.setTextColor(0);
    doc.text(fretStr, nx, ny + 1, { align: 'center' });
  }

  // â”€â”€ Render rows across pages
  let currentPage = 0;
  let pageRowCount = 0;

  for (let ri = 0; ri < totalRows; ri++) {
    const neededPage = Math.floor(ri / ROWS_PER_PAGE);
    if (neededPage > currentPage) {
      doc.addPage();
      currentPage = neededPage;
      pageRowCount = 0;

      // Repeat header on new pages
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(10);
      doc.setTextColor(0);
      doc.text('Song', MARGIN_L, HEADER_Y);
      doc.line(songLineStart, HEADER_Y + 2, songLineEnd, HEADER_Y + 2);
      doc.text('Artist', artistX, HEADER_Y);
      doc.line(artistLineStart, HEADER_Y + 2, artistLineEnd, HEADER_Y + 2);
      if (songName) {
        doc.setFont('helvetica', 'italic');
        doc.setFontSize(9);
        doc.text(songName, songLineStart + 2, HEADER_Y - 1);
        doc.setFont('helvetica', 'normal');
      }
      if (artistName) {
        doc.setFont('helvetica', 'italic');
        doc.setFontSize(9);
        doc.text(artistName, artistLineStart + 2, HEADER_Y - 1);
        doc.setFont('helvetica', 'normal');
      }
    }

    const localRow = ri % ROWS_PER_PAGE;
    const yTop = FIRST_ROW_Y + localRow * ROW_STEP;

    drawStaff(ri, yTop);

    const rowStart = ri * ROW_DUR;
    const rowEnd = rowStart + ROW_DUR;
    const rowNotes = notes.filter(n => n.time >= rowStart && n.time < rowEnd);
    for (const note of rowNotes) drawNote(note, rowStart, yTop);
  }

  return doc.output('blob');
}

// â”€â”€â”€ UI Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const fileName = document.getElementById('fileName');
const processBtn = document.getElementById('processBtn');
const progressWrap = document.getElementById('progressWrap');
const progressBar = document.getElementById('progressBar');
const errorBox = document.getElementById('errorBox');
const resultBox = document.getElementById('resultBox');
const resultInfo = document.getElementById('resultInfo');
const downloadLink = document.getElementById('downloadLink');
const tabPreview = document.getElementById('tabPreview');

let selectedFile = null;
let lastPdfBlob = null;
let lastPdfName = '';

dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', e => {
  e.preventDefault();
  dropzone.classList.remove('dragover');
  if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', () => { if (fileInput.files[0]) handleFile(fileInput.files[0]); });

function handleFile(f) {
  if (!f.name.toLowerCase().endsWith('.mp3') && !f.type.includes('mpeg')) {
    showError('Only MP3 files are accepted.');
    return;
  }
  selectedFile = f;
  fileName.textContent = `â–¸ ${f.name}  (${(f.size / 1024 / 1024).toFixed(2)} MB)`;
  processBtn.disabled = false;
  errorBox.classList.remove('visible');
  resultBox.classList.remove('visible');

  // Auto-fill song name from filename
  const songInput = document.getElementById('songName');
  if (!songInput.value) {
    songInput.value = f.name.replace(/\.mp3$/i, '').replace(/[-_]/g, ' ');
  }
}

function showError(msg) {
  errorBox.textContent = msg;
  errorBox.classList.add('visible');
  resultBox.classList.remove('visible');
}

function setStep(stepId) {
  ['step1','step2','step3','step4'].forEach(id => {
    const el = document.getElementById(id);
    if (el.classList.contains('active')) el.classList.replace('active','done');
    el.classList.remove('active');
  });
  document.getElementById(stepId).classList.add('active');
}

async function processFile() {
  if (!selectedFile) return;

  errorBox.classList.remove('visible');
  resultBox.classList.remove('visible');
  processBtn.disabled = true;
  progressWrap.classList.add('visible');
  ['step1','step2','step3','step4'].forEach(id => {
    document.getElementById(id).className = 'step';
  });
  progressBar.style.width = '5%';

  try {
    // Step 1: Decode
    setStep('step1');
    progressBar.style.width = '8%';
    const arrayBuffer = await selectedFile.arrayBuffer();
    progressBar.style.width = '12%';

    // Step 2: Pitch detection
    setStep('step2');
    // Run in a small delay so UI updates
    await new Promise(r => setTimeout(r, 30));

    let notes;
    try {
      notes = await extractNotes(arrayBuffer, pct => {
        progressBar.style.width = pct + '%';
      });
    } catch (e) {
      throw new Error('Audio decoding failed: ' + e.message);
    }

    progressBar.style.width = '78%';

    if (!notes || notes.length === 0) {
      throw new Error('No pitched bass notes detected. Try an isolated bass track or DI recording.');
    }

    // Step 3: Map
    setStep('step3');
    await new Promise(r => setTimeout(r, 30));
    progressBar.style.width = '85%';

    // Step 4: Generate PDF
    setStep('step4');
    await new Promise(r => setTimeout(r, 30));

    const songName = document.getElementById('songName').value.trim();
    const artistName = document.getElementById('artistName').value.trim();

    const pdfBlob = generatePDF(notes, songName, artistName);
    progressBar.style.width = '100%';

    document.getElementById('step4').classList.replace('active','done');

    lastPdfBlob = pdfBlob;
    const baseName = (songName || selectedFile.name.replace(/\.mp3$/i,''));
    lastPdfName = baseName.replace(/\s+/g,'_') + '_bass_tab.pdf';

    const url = URL.createObjectURL(pdfBlob);
    downloadLink.href = url;
    downloadLink.download = lastPdfName;

    resultInfo.innerHTML = `
      <strong style="color:var(--fg)">${selectedFile.name}</strong><br>
      ${notes.length} notes detected Â· A4 PDF Â· Standard tuning (E A D G)
    `;

    resultBox.classList.add('visible');
    progressWrap.classList.remove('visible');
    downloadLink.click();

  } catch (err) {
    showError('Error: ' + err.message);
    progressWrap.classList.remove('visible');
  }

  processBtn.disabled = false;
}

// â”€â”€ Animated tab preview
const SAMPLE_NOTES = [
  {s:3, f:0},{s:2, f:2},{s:3, f:2},{s:2, f:0},
  {s:1, f:3},{s:2, f:2},{s:3, f:0},{s:2, f:3},
  {s:3, f:2},{s:3, f:0},{s:2, f:5},{s:1, f:2},
];
let dotIdx = 0;
function animateTabDots() {
  tabPreview.querySelectorAll('.tab-dot').forEach(d => d.remove());
  const rows = tabPreview.querySelectorAll('.tab-string-row');
  const note = SAMPLE_NOTES[dotIdx % SAMPLE_NOTES.length];
  const row = rows[note.s];
  if (row) {
    const line = row.querySelector('.tab-string-line');
    const dot = document.createElement('div');
    dot.className = 'tab-dot';
    dot.textContent = note.f;
    dot.style.left = (15 + (dotIdx % 10) * 8) + '%';
    line.appendChild(dot);
  }
  dotIdx++;
  if (dotIdx > 40) dotIdx = 0;
}
setInterval(animateTabDots, 550);
</script>
</body>
</html>
